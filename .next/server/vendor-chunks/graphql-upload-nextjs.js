"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphql-upload-nextjs";
exports.ids = ["vendor-chunks/graphql-upload-nextjs"];
exports.modules = {

/***/ "(rsc)/./node_modules/graphql-upload-nextjs/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphql-upload-nextjs/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GraphQLUpload: () => (/* binding */ GraphQLUpload),\n/* harmony export */   Upload: () => (/* binding */ Upload),\n/* harmony export */   bufferToStream: () => (/* binding */ bufferToStream),\n/* harmony export */   sanitizeAndValidateJSON: () => (/* binding */ sanitizeAndValidateJSON),\n/* harmony export */   streamToBuffer: () => (/* binding */ streamToBuffer),\n/* harmony export */   uploadProcess: () => (/* binding */ uploadProcess)\n/* harmony export */ });\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! graphql */ \"(rsc)/./node_modules/graphql/type/definition.mjs\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! graphql */ \"(rsc)/./node_modules/graphql/error/GraphQLError.mjs\");\n/* harmony import */ var next_server_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server.js */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var file_type__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! file-type */ \"(rsc)/./node_modules/file-type/core.js\");\n/* harmony import */ var istextorbinary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! istextorbinary */ \"(rsc)/./node_modules/istextorbinary/edition-es2017-esm/index.js\");\n\n\n\n\nclass Upload {\n    file;\n    promise;\n    reject = () => { };\n    resolve = () => { };\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = (file) => {\n                this.file = file;\n                resolve(file);\n            };\n            this.reject = reject;\n        });\n        this.promise.catch(() => { });\n    }\n}\nconst GraphQLUpload = new graphql__WEBPACK_IMPORTED_MODULE_2__.GraphQLScalarType({\n    description: 'The Upload scalar type represents a file upload.',\n    name: 'Upload',\n    parseLiteral(node) { throw new graphql__WEBPACK_IMPORTED_MODULE_3__.GraphQLError('Upload literal unsupported.', { nodes: node }); },\n    parseValue(value) { return value instanceof Upload ? value.promise : new graphql__WEBPACK_IMPORTED_MODULE_3__.GraphQLError('Upload value invalid.'); },\n    serialize() { throw new graphql__WEBPACK_IMPORTED_MODULE_3__.GraphQLError('Upload serialization unsupported.'); }\n});\n/**\n * Extract files from form data.\n * @param formData - The form data containing file entries.\n * @returns An object mapping file keys to FormDataFile objects.\n */\nasync function extractFiles(formData) {\n    const files = {};\n    for (const [key, value] of formData.entries()) {\n        if (value instanceof File) {\n            files[key] = value;\n        }\n    }\n    return files;\n}\n/**\n * Stream to buffer utility function.\n * @param stream - The readable stream.\n * @returns A promise that resolves to a buffer.\n */\nasync function streamToBuffer(stream) {\n    const chunks = [];\n    for await (const chunk of stream) {\n        chunks.push(chunk);\n    }\n    return Buffer.concat(chunks);\n}\n/**\n * Buffer to stream utility function.\n * @param buffer - The buffer.\n * @returns A readable stream.\n */\nfunction bufferToStream(buffer) {\n    const { Readable } = require('stream');\n    const stream = new Readable();\n    stream.push(buffer);\n    stream.push(null);\n    return stream;\n}\n/**\n * Sanitize and validate JSON input.\n * @param input - The JSON string to sanitize and validate.\n * @returns The parsed JSON object.\n */\nfunction sanitizeAndValidateJSON(input) {\n    try {\n        const result = JSON.parse(input);\n        if (typeof result !== 'object' || result === null) {\n            throw new Error('Invalid JSON structure');\n        }\n        return result;\n    }\n    catch (error) {\n        console.error('Error parsing JSON:', error);\n        throw new Error('Invalid JSON input');\n    }\n}\n/**\n * Process an individual file upload.\n * @param file - The file to be uploaded.\n * @param variableName - The name of the variable associated with the file.\n * @param operations - The GraphQL operations containing the query and variables.\n * @param allowedTypes - The list of allowed MIME types.\n */\nasync function processUpload(file, variableName, operations, allowedTypes) {\n    // Validate file properties\n    if (!file.name || !file.size || !file.type) {\n        throw new Error('Invalid file properties');\n    }\n    const stream = await file.stream();\n    const buffer = await streamToBuffer(stream);\n    const fileType = await (0,file_type__WEBPACK_IMPORTED_MODULE_4__.fileTypeFromBuffer)(buffer);\n    // Determine the MIME type\n    let mimeType = file.type;\n    if (fileType) {\n        mimeType = fileType.mime;\n    }\n    else if ((0,istextorbinary__WEBPACK_IMPORTED_MODULE_1__.isText)(null, buffer)) {\n        mimeType = 'text/plain';\n    }\n    // Check if the file's MIME type is allowed\n    if (!allowedTypes.includes(mimeType)) {\n        throw new Error(`File type ${mimeType} is not allowed. Allowed types: ${allowedTypes.join(', ')}`);\n    }\n    const upload = new Upload();\n    upload.resolve({\n        fileSize: file.size,\n        fileName: file.name,\n        mimeType: mimeType,\n        encoding: 'binary',\n        createReadStream: () => bufferToStream(buffer)\n    });\n    operations.variables[variableName] = upload;\n}\n/**\n * Main function to handle file uploads in a GraphQL request.\n * @param request - The incoming request containing form data.\n * @param context - The context for the server operation.\n * @param server - The GraphQL server instance.\n * @param settings - The settings for file upload, including maxFileSize and allowedTypes.\n * @returns A response containing the result of the GraphQL operation.\n */\nasync function uploadProcess(request, context, server, settings) {\n    try {\n        // Extract form data from the request\n        const formData = await request.formData();\n        const files = await extractFiles(formData);\n        // Parse and validate the map and operations from the form data\n        const map = sanitizeAndValidateJSON(formData.get('map'));\n        const operations = sanitizeAndValidateJSON(formData.get('operations'));\n        const uploadPromises = [];\n        // Process each file upload based on the map\n        for (const fileKey of Object.keys(map)) {\n            const file = files[fileKey];\n            // Check if the file size exceeds the maximum allowed size\n            if (file.size > settings.maxFileSize) {\n                return next_server_js__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({ error: `File size is too large. Maximum allowed size is ${settings.maxFileSize / (1024 * 1024)}MB.` });\n            }\n            const pathSegment = map[fileKey][0];\n            const variableName = pathSegment.split('.').slice(-1)[0];\n            uploadPromises.push(processUpload(file, variableName, operations, settings.allowedTypes));\n        }\n        // Wait for all upload promises to resolve\n        await Promise.all(uploadPromises);\n        // Remove any variables that were not set\n        for (const key in operations.variables) {\n            if (!operations.variables[key]) {\n                delete operations.variables[key];\n            }\n        }\n        // Execute the GraphQL operation\n        const response = await server.executeOperation({ query: operations.query, variables: operations.variables }, { contextValue: await context });\n        // Return the appropriate response based on the result kind\n        if (response.body.kind === 'single') {\n            const { data, errors } = response.body.singleResult;\n            return next_server_js__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({ data, errors });\n        }\n        else if (response.body.kind === 'incremental') {\n            const { initialResult, subsequentResults } = response.body;\n            const results = [initialResult];\n            for await (const result of subsequentResults) {\n                results.push(result);\n            }\n            return next_server_js__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({ results });\n        }\n    }\n    catch (error) {\n        console.error('Error processing upload:', error);\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        return next_server_js__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({ error: `Error processing upload: ${errorMessage}` });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC11cGxvYWQtbmV4dGpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQ1o7QUFDQztBQUNQO0FBQ2pDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNPLDBCQUEwQixzREFBaUI7QUFDbEQ7QUFDQTtBQUNBLHlCQUF5QixVQUFVLGlEQUFZLGtDQUFrQyxhQUFhLElBQUk7QUFDbEcsd0JBQXdCLHFEQUFxRCxpREFBWSw0QkFBNEI7QUFDckgsa0JBQWtCLFVBQVUsaURBQVk7QUFDeEMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkRBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNEQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFVBQVUsaUNBQWlDLHdCQUF3QjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBWSxRQUFRLDBEQUEwRCxxQ0FBcUMsTUFBTTtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDBEQUEwRCxJQUFJLDZCQUE2QjtBQUNwSjtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsbUJBQW1CLHdEQUFZLFFBQVEsY0FBYztBQUNyRDtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix3REFBWSxRQUFRLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQVksUUFBUSxtQ0FBbUMsYUFBYSxHQUFHO0FBQ3RGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcm9tcHRhc3RpY19zZ2QvLi9ub2RlX21vZHVsZXMvZ3JhcGhxbC11cGxvYWQtbmV4dGpzL2luZGV4LmpzP2M4NWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR3JhcGhRTEVycm9yLCBHcmFwaFFMU2NhbGFyVHlwZSB9IGZyb20gJ2dyYXBocWwnO1xuaW1wb3J0IHsgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXIuanMnO1xuaW1wb3J0IHsgZmlsZVR5cGVGcm9tQnVmZmVyIH0gZnJvbSAnZmlsZS10eXBlJztcbmltcG9ydCB7IGlzVGV4dCB9IGZyb20gJ2lzdGV4dG9yYmluYXJ5JztcbmV4cG9ydCBjbGFzcyBVcGxvYWQge1xuICAgIGZpbGU7XG4gICAgcHJvbWlzZTtcbiAgICByZWplY3QgPSAoKSA9PiB7IH07XG4gICAgcmVzb2x2ZSA9ICgpID0+IHsgfTtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gKGZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZmlsZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb21pc2UuY2F0Y2goKCkgPT4geyB9KTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgR3JhcGhRTFVwbG9hZCA9IG5ldyBHcmFwaFFMU2NhbGFyVHlwZSh7XG4gICAgZGVzY3JpcHRpb246ICdUaGUgVXBsb2FkIHNjYWxhciB0eXBlIHJlcHJlc2VudHMgYSBmaWxlIHVwbG9hZC4nLFxuICAgIG5hbWU6ICdVcGxvYWQnLFxuICAgIHBhcnNlTGl0ZXJhbChub2RlKSB7IHRocm93IG5ldyBHcmFwaFFMRXJyb3IoJ1VwbG9hZCBsaXRlcmFsIHVuc3VwcG9ydGVkLicsIHsgbm9kZXM6IG5vZGUgfSk7IH0sXG4gICAgcGFyc2VWYWx1ZSh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVcGxvYWQgPyB2YWx1ZS5wcm9taXNlIDogbmV3IEdyYXBoUUxFcnJvcignVXBsb2FkIHZhbHVlIGludmFsaWQuJyk7IH0sXG4gICAgc2VyaWFsaXplKCkgeyB0aHJvdyBuZXcgR3JhcGhRTEVycm9yKCdVcGxvYWQgc2VyaWFsaXphdGlvbiB1bnN1cHBvcnRlZC4nKTsgfVxufSk7XG4vKipcbiAqIEV4dHJhY3QgZmlsZXMgZnJvbSBmb3JtIGRhdGEuXG4gKiBAcGFyYW0gZm9ybURhdGEgLSBUaGUgZm9ybSBkYXRhIGNvbnRhaW5pbmcgZmlsZSBlbnRyaWVzLlxuICogQHJldHVybnMgQW4gb2JqZWN0IG1hcHBpbmcgZmlsZSBrZXlzIHRvIEZvcm1EYXRhRmlsZSBvYmplY3RzLlxuICovXG5hc3luYyBmdW5jdGlvbiBleHRyYWN0RmlsZXMoZm9ybURhdGEpIHtcbiAgICBjb25zdCBmaWxlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgICBmaWxlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbGVzO1xufVxuLyoqXG4gKiBTdHJlYW0gdG8gYnVmZmVyIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcGFyYW0gc3RyZWFtIC0gVGhlIHJlYWRhYmxlIHN0cmVhbS5cbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYnVmZmVyLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RyZWFtVG9CdWZmZXIoc3RyZWFtKSB7XG4gICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChjaHVua3MpO1xufVxuLyoqXG4gKiBCdWZmZXIgdG8gc3RyZWFtIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcGFyYW0gYnVmZmVyIC0gVGhlIGJ1ZmZlci5cbiAqIEByZXR1cm5zIEEgcmVhZGFibGUgc3RyZWFtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyVG9TdHJlYW0oYnVmZmVyKSB7XG4gICAgY29uc3QgeyBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlKCk7XG4gICAgc3RyZWFtLnB1c2goYnVmZmVyKTtcbiAgICBzdHJlYW0ucHVzaChudWxsKTtcbiAgICByZXR1cm4gc3RyZWFtO1xufVxuLyoqXG4gKiBTYW5pdGl6ZSBhbmQgdmFsaWRhdGUgSlNPTiBpbnB1dC5cbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSBKU09OIHN0cmluZyB0byBzYW5pdGl6ZSBhbmQgdmFsaWRhdGUuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIEpTT04gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVBbmRWYWxpZGF0ZUpTT04oaW5wdXQpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnIHx8IHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gc3RydWN0dXJlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgSlNPTjonLCBlcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIGlucHV0Jyk7XG4gICAgfVxufVxuLyoqXG4gKiBQcm9jZXNzIGFuIGluZGl2aWR1YWwgZmlsZSB1cGxvYWQuXG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkLlxuICogQHBhcmFtIHZhcmlhYmxlTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSBhc3NvY2lhdGVkIHdpdGggdGhlIGZpbGUuXG4gKiBAcGFyYW0gb3BlcmF0aW9ucyAtIFRoZSBHcmFwaFFMIG9wZXJhdGlvbnMgY29udGFpbmluZyB0aGUgcXVlcnkgYW5kIHZhcmlhYmxlcy5cbiAqIEBwYXJhbSBhbGxvd2VkVHlwZXMgLSBUaGUgbGlzdCBvZiBhbGxvd2VkIE1JTUUgdHlwZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NVcGxvYWQoZmlsZSwgdmFyaWFibGVOYW1lLCBvcGVyYXRpb25zLCBhbGxvd2VkVHlwZXMpIHtcbiAgICAvLyBWYWxpZGF0ZSBmaWxlIHByb3BlcnRpZXNcbiAgICBpZiAoIWZpbGUubmFtZSB8fCAhZmlsZS5zaXplIHx8ICFmaWxlLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZpbGUgcHJvcGVydGllcycpO1xuICAgIH1cbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBmaWxlLnN0cmVhbSgpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHN0cmVhbVRvQnVmZmVyKHN0cmVhbSk7XG4gICAgY29uc3QgZmlsZVR5cGUgPSBhd2FpdCBmaWxlVHlwZUZyb21CdWZmZXIoYnVmZmVyKTtcbiAgICAvLyBEZXRlcm1pbmUgdGhlIE1JTUUgdHlwZVxuICAgIGxldCBtaW1lVHlwZSA9IGZpbGUudHlwZTtcbiAgICBpZiAoZmlsZVR5cGUpIHtcbiAgICAgICAgbWltZVR5cGUgPSBmaWxlVHlwZS5taW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1RleHQobnVsbCwgYnVmZmVyKSkge1xuICAgICAgICBtaW1lVHlwZSA9ICd0ZXh0L3BsYWluJztcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGZpbGUncyBNSU1FIHR5cGUgaXMgYWxsb3dlZFxuICAgIGlmICghYWxsb3dlZFR5cGVzLmluY2x1ZGVzKG1pbWVUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpbGUgdHlwZSAke21pbWVUeXBlfSBpcyBub3QgYWxsb3dlZC4gQWxsb3dlZCB0eXBlczogJHthbGxvd2VkVHlwZXMuam9pbignLCAnKX1gKTtcbiAgICB9XG4gICAgY29uc3QgdXBsb2FkID0gbmV3IFVwbG9hZCgpO1xuICAgIHVwbG9hZC5yZXNvbHZlKHtcbiAgICAgICAgZmlsZVNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgbWltZVR5cGU6IG1pbWVUeXBlLFxuICAgICAgICBlbmNvZGluZzogJ2JpbmFyeScsXG4gICAgICAgIGNyZWF0ZVJlYWRTdHJlYW06ICgpID0+IGJ1ZmZlclRvU3RyZWFtKGJ1ZmZlcilcbiAgICB9KTtcbiAgICBvcGVyYXRpb25zLnZhcmlhYmxlc1t2YXJpYWJsZU5hbWVdID0gdXBsb2FkO1xufVxuLyoqXG4gKiBNYWluIGZ1bmN0aW9uIHRvIGhhbmRsZSBmaWxlIHVwbG9hZHMgaW4gYSBHcmFwaFFMIHJlcXVlc3QuXG4gKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSBpbmNvbWluZyByZXF1ZXN0IGNvbnRhaW5pbmcgZm9ybSBkYXRhLlxuICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCBmb3IgdGhlIHNlcnZlciBvcGVyYXRpb24uXG4gKiBAcGFyYW0gc2VydmVyIC0gVGhlIEdyYXBoUUwgc2VydmVyIGluc3RhbmNlLlxuICogQHBhcmFtIHNldHRpbmdzIC0gVGhlIHNldHRpbmdzIGZvciBmaWxlIHVwbG9hZCwgaW5jbHVkaW5nIG1heEZpbGVTaXplIGFuZCBhbGxvd2VkVHlwZXMuXG4gKiBAcmV0dXJucyBBIHJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgR3JhcGhRTCBvcGVyYXRpb24uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGxvYWRQcm9jZXNzKHJlcXVlc3QsIGNvbnRleHQsIHNlcnZlciwgc2V0dGluZ3MpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBFeHRyYWN0IGZvcm0gZGF0YSBmcm9tIHRoZSByZXF1ZXN0XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gYXdhaXQgcmVxdWVzdC5mb3JtRGF0YSgpO1xuICAgICAgICBjb25zdCBmaWxlcyA9IGF3YWl0IGV4dHJhY3RGaWxlcyhmb3JtRGF0YSk7XG4gICAgICAgIC8vIFBhcnNlIGFuZCB2YWxpZGF0ZSB0aGUgbWFwIGFuZCBvcGVyYXRpb25zIGZyb20gdGhlIGZvcm0gZGF0YVxuICAgICAgICBjb25zdCBtYXAgPSBzYW5pdGl6ZUFuZFZhbGlkYXRlSlNPTihmb3JtRGF0YS5nZXQoJ21hcCcpKTtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9ucyA9IHNhbml0aXplQW5kVmFsaWRhdGVKU09OKGZvcm1EYXRhLmdldCgnb3BlcmF0aW9ucycpKTtcbiAgICAgICAgY29uc3QgdXBsb2FkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIGZpbGUgdXBsb2FkIGJhc2VkIG9uIHRoZSBtYXBcbiAgICAgICAgZm9yIChjb25zdCBmaWxlS2V5IG9mIE9iamVjdC5rZXlzKG1hcCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlc1tmaWxlS2V5XTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaWxlIHNpemUgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemVcbiAgICAgICAgICAgIGlmIChmaWxlLnNpemUgPiBzZXR0aW5ncy5tYXhGaWxlU2l6ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiBgRmlsZSBzaXplIGlzIHRvbyBsYXJnZS4gTWF4aW11bSBhbGxvd2VkIHNpemUgaXMgJHtzZXR0aW5ncy5tYXhGaWxlU2l6ZSAvICgxMDI0ICogMTAyNCl9TUIuYCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhdGhTZWdtZW50ID0gbWFwW2ZpbGVLZXldWzBdO1xuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gcGF0aFNlZ21lbnQuc3BsaXQoJy4nKS5zbGljZSgtMSlbMF07XG4gICAgICAgICAgICB1cGxvYWRQcm9taXNlcy5wdXNoKHByb2Nlc3NVcGxvYWQoZmlsZSwgdmFyaWFibGVOYW1lLCBvcGVyYXRpb25zLCBzZXR0aW5ncy5hbGxvd2VkVHlwZXMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IGZvciBhbGwgdXBsb2FkIHByb21pc2VzIHRvIHJlc29sdmVcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodXBsb2FkUHJvbWlzZXMpO1xuICAgICAgICAvLyBSZW1vdmUgYW55IHZhcmlhYmxlcyB0aGF0IHdlcmUgbm90IHNldFxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcGVyYXRpb25zLnZhcmlhYmxlcykge1xuICAgICAgICAgICAgaWYgKCFvcGVyYXRpb25zLnZhcmlhYmxlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wZXJhdGlvbnMudmFyaWFibGVzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhlY3V0ZSB0aGUgR3JhcGhRTCBvcGVyYXRpb25cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZXJ2ZXIuZXhlY3V0ZU9wZXJhdGlvbih7IHF1ZXJ5OiBvcGVyYXRpb25zLnF1ZXJ5LCB2YXJpYWJsZXM6IG9wZXJhdGlvbnMudmFyaWFibGVzIH0sIHsgY29udGV4dFZhbHVlOiBhd2FpdCBjb250ZXh0IH0pO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHJlc3BvbnNlIGJhc2VkIG9uIHRoZSByZXN1bHQga2luZFxuICAgICAgICBpZiAocmVzcG9uc2UuYm9keS5raW5kID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcnMgfSA9IHJlc3BvbnNlLmJvZHkuc2luZ2xlUmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZGF0YSwgZXJyb3JzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLmJvZHkua2luZCA9PT0gJ2luY3JlbWVudGFsJykge1xuICAgICAgICAgICAgY29uc3QgeyBpbml0aWFsUmVzdWx0LCBzdWJzZXF1ZW50UmVzdWx0cyB9ID0gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbaW5pdGlhbFJlc3VsdF07XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHJlc3VsdCBvZiBzdWJzZXF1ZW50UmVzdWx0cykge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgcmVzdWx0cyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcHJvY2Vzc2luZyB1cGxvYWQ6JywgZXJyb3IpO1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJztcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgZXJyb3I6IGBFcnJvciBwcm9jZXNzaW5nIHVwbG9hZDogJHtlcnJvck1lc3NhZ2V9YCB9KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/graphql-upload-nextjs/index.js\n");

/***/ })

};
;