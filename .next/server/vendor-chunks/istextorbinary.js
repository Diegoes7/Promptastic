"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/istextorbinary";
exports.ids = ["vendor-chunks/istextorbinary"];
exports.modules = {

/***/ "(rsc)/./node_modules/istextorbinary/edition-es2017-esm/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/istextorbinary/edition-es2017-esm/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEncoding: () => (/* binding */ getEncoding),\n/* harmony export */   isBinary: () => (/* binding */ isBinary),\n/* harmony export */   isText: () => (/* binding */ isText)\n/* harmony export */ });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var textextensions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! textextensions */ \"(rsc)/./node_modules/textextensions/edition-es2022-esm/index.js\");\n/* harmony import */ var binaryextensions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! binaryextensions */ \"(rsc)/./node_modules/binaryextensions/edition-es2022-esm/index.js\");\n/* eslint no-use-before-define:0 */\n\n\n\n/**\n * Determine if the filename and/or buffer is text.\n * Determined by extension checks first (if filename is available), otherwise if unknown extension or no filename, will perform a slower buffer encoding detection.\n * This order is done, as extension checks are quicker, and also because encoding checks cannot guarantee accuracy for chars between utf8 and utf16.\n * The extension checks are performed using the resources https://github.com/bevry/textextensions and https://github.com/bevry/binaryextensions\n * @param filename The filename for the file/buffer if available\n * @param buffer The buffer for the file if available\n * @returns Will be `null` if neither `filename` nor `buffer` were provided. Otherwise will be a boolean value with the detection result.\n */\nfunction isText(filename, buffer) {\n    // Test extensions\n    if (filename) {\n        // Extract filename\n        const parts = path__WEBPACK_IMPORTED_MODULE_0__.basename(filename).split('.').reverse();\n        // Cycle extensions\n        for (const extension of parts) {\n            if (textextensions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].indexOf(extension) !== -1) {\n                return true;\n            }\n            if (binaryextensions__WEBPACK_IMPORTED_MODULE_2__[\"default\"].indexOf(extension) !== -1) {\n                return false;\n            }\n        }\n    }\n    // Fallback to encoding if extension check was not enough\n    if (buffer) {\n        return getEncoding(buffer) === 'utf8';\n    }\n    // No buffer was provided\n    return null;\n}\n/**\n * Determine if the filename and/or buffer is binary.\n * Determined by extension checks first (if filename is available), otherwise if unknown extension or no filename, will perform a slower buffer encoding detection.\n * This order is done, as extension checks are quicker, and also because encoding checks cannot guarantee accuracy for chars between utf8 and utf16.\n * The extension checks are performed using the resources https://github.com/bevry/textextensions and https://github.com/bevry/binaryextensions\n * @param filename The filename for the file/buffer if available\n * @param buffer The buffer for the file if available\n * @returns Will be `null` if neither `filename` nor `buffer` were provided. Otherwise will be a boolean value with the detection result.\n */\nfunction isBinary(filename, buffer) {\n    const text = isText(filename, buffer);\n    if (text == null)\n        return null;\n    return !text;\n}\n/**\n * Get the encoding of a buffer.\n * Checks the start, middle, and end of the buffer for characters that are unrecognized within UTF8 encoding.\n * History has shown that inspection at all three locations is necessary.\n * @returns Will be `null` if `buffer` was not provided. Otherwise will be either `'utf8'` or `'binary'`\n */\nfunction getEncoding(buffer, opts) {\n    var _a, _b;\n    // Check\n    if (!buffer)\n        return null;\n    // Prepare\n    const textEncoding = 'utf8';\n    const binaryEncoding = 'binary';\n    const chunkLength = (_a = opts === null || opts === void 0 ? void 0 : opts.chunkLength) !== null && _a !== void 0 ? _a : 24;\n    let chunkBegin = (_b = opts === null || opts === void 0 ? void 0 : opts.chunkBegin) !== null && _b !== void 0 ? _b : 0;\n    // Discover\n    if ((opts === null || opts === void 0 ? void 0 : opts.chunkBegin) == null) {\n        // Start\n        let encoding = getEncoding(buffer, { chunkLength, chunkBegin });\n        if (encoding === textEncoding) {\n            // Middle\n            chunkBegin = Math.max(0, Math.floor(buffer.length / 2) - chunkLength);\n            encoding = getEncoding(buffer, {\n                chunkLength,\n                chunkBegin,\n            });\n            if (encoding === textEncoding) {\n                // End\n                chunkBegin = Math.max(0, buffer.length - chunkLength);\n                encoding = getEncoding(buffer, {\n                    chunkLength,\n                    chunkBegin,\n                });\n            }\n        }\n        // Return\n        return encoding;\n    }\n    else {\n        // Extract\n        chunkBegin = getChunkBegin(buffer, chunkBegin);\n        if (chunkBegin === -1) {\n            return binaryEncoding;\n        }\n        const chunkEnd = getChunkEnd(buffer, Math.min(buffer.length, chunkBegin + chunkLength));\n        if (chunkEnd > buffer.length) {\n            return binaryEncoding;\n        }\n        const contentChunkUTF8 = buffer.toString(textEncoding, chunkBegin, chunkEnd);\n        // Detect encoding\n        for (let i = 0; i < contentChunkUTF8.length; ++i) {\n            const charCode = contentChunkUTF8.charCodeAt(i);\n            if (charCode === 65533 || charCode <= 8) {\n                // 8 and below are control characters (e.g. backspace, null, eof, etc.)\n                // 65533 is the unknown character\n                // console.log(charCode, contentChunkUTF8[i])\n                return binaryEncoding;\n            }\n        }\n        // Return\n        return textEncoding;\n    }\n}\n// ====================================\n// The functions below are created to handle multibyte utf8 characters.\n// To understand how the encoding works, check this article: https://en.wikipedia.org/wiki/UTF-8#Encoding\n// @todo add documentation for these\nfunction getChunkBegin(buf, chunkBegin) {\n    // If it's the beginning, just return.\n    if (chunkBegin === 0) {\n        return 0;\n    }\n    if (!isLaterByteOfUtf8(buf[chunkBegin])) {\n        return chunkBegin;\n    }\n    let begin = chunkBegin - 3;\n    if (begin >= 0) {\n        if (isFirstByteOf4ByteChar(buf[begin])) {\n            return begin;\n        }\n    }\n    begin = chunkBegin - 2;\n    if (begin >= 0) {\n        if (isFirstByteOf4ByteChar(buf[begin]) ||\n            isFirstByteOf3ByteChar(buf[begin])) {\n            return begin;\n        }\n    }\n    begin = chunkBegin - 1;\n    if (begin >= 0) {\n        // Is it a 4-byte, 3-byte utf8 character?\n        if (isFirstByteOf4ByteChar(buf[begin]) ||\n            isFirstByteOf3ByteChar(buf[begin]) ||\n            isFirstByteOf2ByteChar(buf[begin])) {\n            return begin;\n        }\n    }\n    return -1;\n}\nfunction getChunkEnd(buf, chunkEnd) {\n    // If it's the end, just return.\n    if (chunkEnd === buf.length) {\n        return chunkEnd;\n    }\n    let index = chunkEnd - 3;\n    if (index >= 0) {\n        if (isFirstByteOf4ByteChar(buf[index])) {\n            return chunkEnd + 1;\n        }\n    }\n    index = chunkEnd - 2;\n    if (index >= 0) {\n        if (isFirstByteOf4ByteChar(buf[index])) {\n            return chunkEnd + 2;\n        }\n        if (isFirstByteOf3ByteChar(buf[index])) {\n            return chunkEnd + 1;\n        }\n    }\n    index = chunkEnd - 1;\n    if (index >= 0) {\n        if (isFirstByteOf4ByteChar(buf[index])) {\n            return chunkEnd + 3;\n        }\n        if (isFirstByteOf3ByteChar(buf[index])) {\n            return chunkEnd + 2;\n        }\n        if (isFirstByteOf2ByteChar(buf[index])) {\n            return chunkEnd + 1;\n        }\n    }\n    return chunkEnd;\n}\nfunction isFirstByteOf4ByteChar(byte) {\n    // eslint-disable-next-line no-bitwise\n    return byte >> 3 === 30; // 11110xxx?\n}\nfunction isFirstByteOf3ByteChar(byte) {\n    // eslint-disable-next-line no-bitwise\n    return byte >> 4 === 14; // 1110xxxx?\n}\nfunction isFirstByteOf2ByteChar(byte) {\n    // eslint-disable-next-line no-bitwise\n    return byte >> 5 === 6; // 110xxxxx?\n}\nfunction isLaterByteOfUtf8(byte) {\n    // eslint-disable-next-line no-bitwise\n    return byte >> 6 === 2; // 10xxxxxx?\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXN0ZXh0b3JiaW5hcnkvZWRpdGlvbi1lczIwMTctZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ2lDO0FBQ1c7QUFDSTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQ0FBaUI7QUFDdkM7QUFDQTtBQUNBLGdCQUFnQixzREFBYztBQUM5QjtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseUJBQXlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJvbXB0YXN0aWNfc2dkLy4vbm9kZV9tb2R1bGVzL2lzdGV4dG9yYmluYXJ5L2VkaXRpb24tZXMyMDE3LWVzbS9pbmRleC5qcz8yMjI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11c2UtYmVmb3JlLWRlZmluZTowICovXG5pbXBvcnQgKiBhcyBwYXRoVXRpbCBmcm9tICdwYXRoJztcbmltcG9ydCB0ZXh0RXh0ZW5zaW9ucyBmcm9tICd0ZXh0ZXh0ZW5zaW9ucyc7XG5pbXBvcnQgYmluYXJ5RXh0ZW5zaW9ucyBmcm9tICdiaW5hcnlleHRlbnNpb25zJztcbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBmaWxlbmFtZSBhbmQvb3IgYnVmZmVyIGlzIHRleHQuXG4gKiBEZXRlcm1pbmVkIGJ5IGV4dGVuc2lvbiBjaGVja3MgZmlyc3QgKGlmIGZpbGVuYW1lIGlzIGF2YWlsYWJsZSksIG90aGVyd2lzZSBpZiB1bmtub3duIGV4dGVuc2lvbiBvciBubyBmaWxlbmFtZSwgd2lsbCBwZXJmb3JtIGEgc2xvd2VyIGJ1ZmZlciBlbmNvZGluZyBkZXRlY3Rpb24uXG4gKiBUaGlzIG9yZGVyIGlzIGRvbmUsIGFzIGV4dGVuc2lvbiBjaGVja3MgYXJlIHF1aWNrZXIsIGFuZCBhbHNvIGJlY2F1c2UgZW5jb2RpbmcgY2hlY2tzIGNhbm5vdCBndWFyYW50ZWUgYWNjdXJhY3kgZm9yIGNoYXJzIGJldHdlZW4gdXRmOCBhbmQgdXRmMTYuXG4gKiBUaGUgZXh0ZW5zaW9uIGNoZWNrcyBhcmUgcGVyZm9ybWVkIHVzaW5nIHRoZSByZXNvdXJjZXMgaHR0cHM6Ly9naXRodWIuY29tL2JldnJ5L3RleHRleHRlbnNpb25zIGFuZCBodHRwczovL2dpdGh1Yi5jb20vYmV2cnkvYmluYXJ5ZXh0ZW5zaW9uc1xuICogQHBhcmFtIGZpbGVuYW1lIFRoZSBmaWxlbmFtZSBmb3IgdGhlIGZpbGUvYnVmZmVyIGlmIGF2YWlsYWJsZVxuICogQHBhcmFtIGJ1ZmZlciBUaGUgYnVmZmVyIGZvciB0aGUgZmlsZSBpZiBhdmFpbGFibGVcbiAqIEByZXR1cm5zIFdpbGwgYmUgYG51bGxgIGlmIG5laXRoZXIgYGZpbGVuYW1lYCBub3IgYGJ1ZmZlcmAgd2VyZSBwcm92aWRlZC4gT3RoZXJ3aXNlIHdpbGwgYmUgYSBib29sZWFuIHZhbHVlIHdpdGggdGhlIGRldGVjdGlvbiByZXN1bHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1RleHQoZmlsZW5hbWUsIGJ1ZmZlcikge1xuICAgIC8vIFRlc3QgZXh0ZW5zaW9uc1xuICAgIGlmIChmaWxlbmFtZSkge1xuICAgICAgICAvLyBFeHRyYWN0IGZpbGVuYW1lXG4gICAgICAgIGNvbnN0IHBhcnRzID0gcGF0aFV0aWwuYmFzZW5hbWUoZmlsZW5hbWUpLnNwbGl0KCcuJykucmV2ZXJzZSgpO1xuICAgICAgICAvLyBDeWNsZSBleHRlbnNpb25zXG4gICAgICAgIGZvciAoY29uc3QgZXh0ZW5zaW9uIG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBpZiAodGV4dEV4dGVuc2lvbnMuaW5kZXhPZihleHRlbnNpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpbmFyeUV4dGVuc2lvbnMuaW5kZXhPZihleHRlbnNpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBlbmNvZGluZyBpZiBleHRlbnNpb24gY2hlY2sgd2FzIG5vdCBlbm91Z2hcbiAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBnZXRFbmNvZGluZyhidWZmZXIpID09PSAndXRmOCc7XG4gICAgfVxuICAgIC8vIE5vIGJ1ZmZlciB3YXMgcHJvdmlkZWRcbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBmaWxlbmFtZSBhbmQvb3IgYnVmZmVyIGlzIGJpbmFyeS5cbiAqIERldGVybWluZWQgYnkgZXh0ZW5zaW9uIGNoZWNrcyBmaXJzdCAoaWYgZmlsZW5hbWUgaXMgYXZhaWxhYmxlKSwgb3RoZXJ3aXNlIGlmIHVua25vd24gZXh0ZW5zaW9uIG9yIG5vIGZpbGVuYW1lLCB3aWxsIHBlcmZvcm0gYSBzbG93ZXIgYnVmZmVyIGVuY29kaW5nIGRldGVjdGlvbi5cbiAqIFRoaXMgb3JkZXIgaXMgZG9uZSwgYXMgZXh0ZW5zaW9uIGNoZWNrcyBhcmUgcXVpY2tlciwgYW5kIGFsc28gYmVjYXVzZSBlbmNvZGluZyBjaGVja3MgY2Fubm90IGd1YXJhbnRlZSBhY2N1cmFjeSBmb3IgY2hhcnMgYmV0d2VlbiB1dGY4IGFuZCB1dGYxNi5cbiAqIFRoZSBleHRlbnNpb24gY2hlY2tzIGFyZSBwZXJmb3JtZWQgdXNpbmcgdGhlIHJlc291cmNlcyBodHRwczovL2dpdGh1Yi5jb20vYmV2cnkvdGV4dGV4dGVuc2lvbnMgYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXZyeS9iaW5hcnlleHRlbnNpb25zXG4gKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIGZvciB0aGUgZmlsZS9idWZmZXIgaWYgYXZhaWxhYmxlXG4gKiBAcGFyYW0gYnVmZmVyIFRoZSBidWZmZXIgZm9yIHRoZSBmaWxlIGlmIGF2YWlsYWJsZVxuICogQHJldHVybnMgV2lsbCBiZSBgbnVsbGAgaWYgbmVpdGhlciBgZmlsZW5hbWVgIG5vciBgYnVmZmVyYCB3ZXJlIHByb3ZpZGVkLiBPdGhlcndpc2Ugd2lsbCBiZSBhIGJvb2xlYW4gdmFsdWUgd2l0aCB0aGUgZGV0ZWN0aW9uIHJlc3VsdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQmluYXJ5KGZpbGVuYW1lLCBidWZmZXIpIHtcbiAgICBjb25zdCB0ZXh0ID0gaXNUZXh0KGZpbGVuYW1lLCBidWZmZXIpO1xuICAgIGlmICh0ZXh0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAhdGV4dDtcbn1cbi8qKlxuICogR2V0IHRoZSBlbmNvZGluZyBvZiBhIGJ1ZmZlci5cbiAqIENoZWNrcyB0aGUgc3RhcnQsIG1pZGRsZSwgYW5kIGVuZCBvZiB0aGUgYnVmZmVyIGZvciBjaGFyYWN0ZXJzIHRoYXQgYXJlIHVucmVjb2duaXplZCB3aXRoaW4gVVRGOCBlbmNvZGluZy5cbiAqIEhpc3RvcnkgaGFzIHNob3duIHRoYXQgaW5zcGVjdGlvbiBhdCBhbGwgdGhyZWUgbG9jYXRpb25zIGlzIG5lY2Vzc2FyeS5cbiAqIEByZXR1cm5zIFdpbGwgYmUgYG51bGxgIGlmIGBidWZmZXJgIHdhcyBub3QgcHJvdmlkZWQuIE90aGVyd2lzZSB3aWxsIGJlIGVpdGhlciBgJ3V0ZjgnYCBvciBgJ2JpbmFyeSdgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbmNvZGluZyhidWZmZXIsIG9wdHMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIC8vIENoZWNrXG4gICAgaWYgKCFidWZmZXIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIC8vIFByZXBhcmVcbiAgICBjb25zdCB0ZXh0RW5jb2RpbmcgPSAndXRmOCc7XG4gICAgY29uc3QgYmluYXJ5RW5jb2RpbmcgPSAnYmluYXJ5JztcbiAgICBjb25zdCBjaHVua0xlbmd0aCA9IChfYSA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5jaHVua0xlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMjQ7XG4gICAgbGV0IGNodW5rQmVnaW4gPSAoX2IgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuY2h1bmtCZWdpbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAvLyBEaXNjb3ZlclxuICAgIGlmICgob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmNodW5rQmVnaW4pID09IG51bGwpIHtcbiAgICAgICAgLy8gU3RhcnRcbiAgICAgICAgbGV0IGVuY29kaW5nID0gZ2V0RW5jb2RpbmcoYnVmZmVyLCB7IGNodW5rTGVuZ3RoLCBjaHVua0JlZ2luIH0pO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09IHRleHRFbmNvZGluZykge1xuICAgICAgICAgICAgLy8gTWlkZGxlXG4gICAgICAgICAgICBjaHVua0JlZ2luID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihidWZmZXIubGVuZ3RoIC8gMikgLSBjaHVua0xlbmd0aCk7XG4gICAgICAgICAgICBlbmNvZGluZyA9IGdldEVuY29kaW5nKGJ1ZmZlciwge1xuICAgICAgICAgICAgICAgIGNodW5rTGVuZ3RoLFxuICAgICAgICAgICAgICAgIGNodW5rQmVnaW4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gdGV4dEVuY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gRW5kXG4gICAgICAgICAgICAgICAgY2h1bmtCZWdpbiA9IE1hdGgubWF4KDAsIGJ1ZmZlci5sZW5ndGggLSBjaHVua0xlbmd0aCk7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBnZXRFbmNvZGluZyhidWZmZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGNodW5rQmVnaW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuXG4gICAgICAgIHJldHVybiBlbmNvZGluZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEV4dHJhY3RcbiAgICAgICAgY2h1bmtCZWdpbiA9IGdldENodW5rQmVnaW4oYnVmZmVyLCBjaHVua0JlZ2luKTtcbiAgICAgICAgaWYgKGNodW5rQmVnaW4gPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluYXJ5RW5jb2Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2h1bmtFbmQgPSBnZXRDaHVua0VuZChidWZmZXIsIE1hdGgubWluKGJ1ZmZlci5sZW5ndGgsIGNodW5rQmVnaW4gKyBjaHVua0xlbmd0aCkpO1xuICAgICAgICBpZiAoY2h1bmtFbmQgPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluYXJ5RW5jb2Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudENodW5rVVRGOCA9IGJ1ZmZlci50b1N0cmluZyh0ZXh0RW5jb2RpbmcsIGNodW5rQmVnaW4sIGNodW5rRW5kKTtcbiAgICAgICAgLy8gRGV0ZWN0IGVuY29kaW5nXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudENodW5rVVRGOC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjb250ZW50Q2h1bmtVVEY4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPT09IDY1NTMzIHx8IGNoYXJDb2RlIDw9IDgpIHtcbiAgICAgICAgICAgICAgICAvLyA4IGFuZCBiZWxvdyBhcmUgY29udHJvbCBjaGFyYWN0ZXJzIChlLmcuIGJhY2tzcGFjZSwgbnVsbCwgZW9mLCBldGMuKVxuICAgICAgICAgICAgICAgIC8vIDY1NTMzIGlzIHRoZSB1bmtub3duIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGNoYXJDb2RlLCBjb250ZW50Q2h1bmtVVEY4W2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiBiaW5hcnlFbmNvZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm5cbiAgICAgICAgcmV0dXJuIHRleHRFbmNvZGluZztcbiAgICB9XG59XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFRoZSBmdW5jdGlvbnMgYmVsb3cgYXJlIGNyZWF0ZWQgdG8gaGFuZGxlIG11bHRpYnl0ZSB1dGY4IGNoYXJhY3RlcnMuXG4vLyBUbyB1bmRlcnN0YW5kIGhvdyB0aGUgZW5jb2Rpbmcgd29ya3MsIGNoZWNrIHRoaXMgYXJ0aWNsZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRW5jb2Rpbmdcbi8vIEB0b2RvIGFkZCBkb2N1bWVudGF0aW9uIGZvciB0aGVzZVxuZnVuY3Rpb24gZ2V0Q2h1bmtCZWdpbihidWYsIGNodW5rQmVnaW4pIHtcbiAgICAvLyBJZiBpdCdzIHRoZSBiZWdpbm5pbmcsIGp1c3QgcmV0dXJuLlxuICAgIGlmIChjaHVua0JlZ2luID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoIWlzTGF0ZXJCeXRlT2ZVdGY4KGJ1ZltjaHVua0JlZ2luXSkpIHtcbiAgICAgICAgcmV0dXJuIGNodW5rQmVnaW47XG4gICAgfVxuICAgIGxldCBiZWdpbiA9IGNodW5rQmVnaW4gLSAzO1xuICAgIGlmIChiZWdpbiA+PSAwKSB7XG4gICAgICAgIGlmIChpc0ZpcnN0Qnl0ZU9mNEJ5dGVDaGFyKGJ1ZltiZWdpbl0pKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVnaW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmVnaW4gPSBjaHVua0JlZ2luIC0gMjtcbiAgICBpZiAoYmVnaW4gPj0gMCkge1xuICAgICAgICBpZiAoaXNGaXJzdEJ5dGVPZjRCeXRlQ2hhcihidWZbYmVnaW5dKSB8fFxuICAgICAgICAgICAgaXNGaXJzdEJ5dGVPZjNCeXRlQ2hhcihidWZbYmVnaW5dKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJlZ2luO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJlZ2luID0gY2h1bmtCZWdpbiAtIDE7XG4gICAgaWYgKGJlZ2luID49IDApIHtcbiAgICAgICAgLy8gSXMgaXQgYSA0LWJ5dGUsIDMtYnl0ZSB1dGY4IGNoYXJhY3Rlcj9cbiAgICAgICAgaWYgKGlzRmlyc3RCeXRlT2Y0Qnl0ZUNoYXIoYnVmW2JlZ2luXSkgfHxcbiAgICAgICAgICAgIGlzRmlyc3RCeXRlT2YzQnl0ZUNoYXIoYnVmW2JlZ2luXSkgfHxcbiAgICAgICAgICAgIGlzRmlyc3RCeXRlT2YyQnl0ZUNoYXIoYnVmW2JlZ2luXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBiZWdpbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBnZXRDaHVua0VuZChidWYsIGNodW5rRW5kKSB7XG4gICAgLy8gSWYgaXQncyB0aGUgZW5kLCBqdXN0IHJldHVybi5cbiAgICBpZiAoY2h1bmtFbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNodW5rRW5kO1xuICAgIH1cbiAgICBsZXQgaW5kZXggPSBjaHVua0VuZCAtIDM7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgaWYgKGlzRmlyc3RCeXRlT2Y0Qnl0ZUNoYXIoYnVmW2luZGV4XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVua0VuZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5kZXggPSBjaHVua0VuZCAtIDI7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgaWYgKGlzRmlyc3RCeXRlT2Y0Qnl0ZUNoYXIoYnVmW2luZGV4XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVua0VuZCArIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRmlyc3RCeXRlT2YzQnl0ZUNoYXIoYnVmW2luZGV4XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVua0VuZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5kZXggPSBjaHVua0VuZCAtIDE7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgaWYgKGlzRmlyc3RCeXRlT2Y0Qnl0ZUNoYXIoYnVmW2luZGV4XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVua0VuZCArIDM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRmlyc3RCeXRlT2YzQnl0ZUNoYXIoYnVmW2luZGV4XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVua0VuZCArIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRmlyc3RCeXRlT2YyQnl0ZUNoYXIoYnVmW2luZGV4XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVua0VuZCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNodW5rRW5kO1xufVxuZnVuY3Rpb24gaXNGaXJzdEJ5dGVPZjRCeXRlQ2hhcihieXRlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICByZXR1cm4gYnl0ZSA+PiAzID09PSAzMDsgLy8gMTExMTB4eHg/XG59XG5mdW5jdGlvbiBpc0ZpcnN0Qnl0ZU9mM0J5dGVDaGFyKGJ5dGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIHJldHVybiBieXRlID4+IDQgPT09IDE0OyAvLyAxMTEweHh4eD9cbn1cbmZ1bmN0aW9uIGlzRmlyc3RCeXRlT2YyQnl0ZUNoYXIoYnl0ZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgcmV0dXJuIGJ5dGUgPj4gNSA9PT0gNjsgLy8gMTEweHh4eHg/XG59XG5mdW5jdGlvbiBpc0xhdGVyQnl0ZU9mVXRmOChieXRlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICByZXR1cm4gYnl0ZSA+PiA2ID09PSAyOyAvLyAxMHh4eHh4eD9cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/istextorbinary/edition-es2017-esm/index.js\n");

/***/ })

};
;